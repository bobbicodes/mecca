["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$zprint.finish","~:imports",null,"~:requires",["^ ","~$s","~$clojure.string","^;","^;","~$zprint.ansi","^<","~$zprint.focus","^="],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$type-ssv","^=","~$color-str","^<","~$range-ssv","^="],"~:defs",["^ ","~$color-comp-vec",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","~:line",234,"~:column",7,"~:end-line",234,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^M",[["~$comp-vec"]]]]],"~:doc","Use output from compress-style -- but just the [string :style] part,\n  which since we used identity as the color map, should be just\n  [string :color].  Produce a single string with ansi escape sequences embedded\n  in it."],"^7","~$zprint.finish/color-comp-vec","~:variadic",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",21,"~:method-params",["^M",[["^O"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^I",1,"^H",234,"^J",234,"~:max-fixed-arity",1,"~:fn-var",true,"^L",["^M",["^N",["^M",[["^O"]]]]],"^P","Use output from compress-style -- but just the [string :style] part,\n  which since we used identity as the color map, should be just\n  [string :color].  Produce a single string with ansi escape sequences embedded\n  in it."],"~$no-style-map",["^ ","^7","~$zprint.finish/no-style-map","^G","resources/public/cljs-out/dev/zprint/finish.cljc","^H",12,"^I",1,"^J",12,"^K",18,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",12,"^I",6,"^J",12,"^K",18],"~:tag","~$cljs.core/IMap"],"~$floor",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",255,"^I",7,"^J",255,"^K",12,"^L",["^M",["^N",["^M",[["~$f","~$n"]]]]],"^P","Ensure one number is above a certain value."],"^7","~$zprint.finish/floor","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",12,"^S",["^M",[["~$f","~$n"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",255,"^J",255,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["~$f","~$n"]]]]],"^P","Ensure one number is above a certain value."],"~$gc-vec-to-style-vec",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",59,"^I",7,"^J",59,"^K",26,"^L",["^M",["^N",["^M",[["~$ctx","~$idx",["~$s","~$keyword-color","~$element"]]]]]],"^P","Take an index and a [string :color element] and produce a\n  [string :style element] with the correct elements (i.e., the\n  elements with the correct idx) having a different \n  background for focus output. The ctx is a map which\n  must have a :style-map and may have a :focus.  The\n  :focus is a two element vector of start and end elements\n  which are in focus."],"^7","~$zprint.finish/gc-vec-to-style-vec","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",26,"^S",["^M",[["^13","^14","~$p__11382"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",59,"^J",59,"^V",3,"^W",true,"^L",["^M",["^N",["^M",[["^13","^14",["~$s","^15","^16"]]]]]],"^P","Take an index and a [string :color element] and produce a\n  [string :style element] with the correct elements (i.e., the\n  elements with the correct idx) having a different \n  background for focus output. The ctx is a map which\n  must have a :style-map and may have a :focus.  The\n  :focus is a two element vector of start and end elements\n  which are in focus."],"~$trim-vec",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",72,"^I",7,"^J",72,"^K",15,"^L",["^M",["^N",["^M",[["~$n","~$v"]]]]],"^P","Take a vector of any length, and trim it to be\n  only n elements in length."],"^7","~$zprint.finish/trim-vec","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",15,"^S",["^M",[["~$n","~$v"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",72,"^J",72,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["~$n","~$v"]]]]],"^P","Take a vector of any length, and trim it to be\n  only n elements in length."],"~$cvec-to-style-vec",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",140,"^I",7,"^J",140,"^K",24,"^L",["^M",["^N",["^M",[["^13","~$cvec","~$focus-vec","~$select-vec"],["^13","^1<"],["^13","^1<","^1="]]]]],"^P","Take a [[string :color <anything>] \n           [string :color <anything>] ...] input.\n  The focus is a vector of [start-focus end-focus] which are the \n  inclusive values for the focus.  The end is inclusive because it \n  gets a bit dicey if it was 'beyond', since how much beyond would \n  be interesting given the amount of whitespace in the input.\n  Not clear at this point just what the counts in the focus-vec count,\n  possibly things with <anything> == :element, possibly just any\n  [string color <anything>] vector.\n  From this, build of: [[string :style] [string :style] ...], where\n  :style might be a color, like :blue or :none, or it might be a \n  java-text-pane style (which would have a color encoded in it).  This\n  is based on the :style-map in the ctx map. Note that this :style-map\n  doesn't have any relation to the :style-map in the options map.","~:top-fn",["^ ","^R",false,"^V",4,"^S",["^M",[["^13","^1<","^1=","^1>"],["^13","^1<"],["^13","^1<","^1="]]],"^L",["^M",[["^13","^1<","^1=","^1>"],["^13","^1<"],["^13","^1<","^1="]]],"^U",["^M",[null,null,null]]]],"^7","~$zprint.finish/cvec-to-style-vec","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",24,"^1?",["^ ","^R",false,"^V",4,"^S",["^M",[["^13","^1<","^1=","^1>"],["^13","^1<"],["^13","^1<","^1="]]],"^L",["^M",[["^13","^1<","^1=","^1>"],["^13","^1<"],["^13","^1<","^1="]]],"^U",["^M",[null,null,null]]],"^S",["^M",[["^13","^1<","^1=","^1>"],["^13","^1<"],["^13","^1<","^1="]]],"^T",null,"^U",["^M",[null,null,null]],"^I",1,"^H",140,"^J",140,"^V",4,"^W",true,"^L",["^M",[["^13","^1<","^1=","^1>"],["^13","^1<"],["^13","^1<","^1="]]],"^P","Take a [[string :color <anything>] \n           [string :color <anything>] ...] input.\n  The focus is a vector of [start-focus end-focus] which are the \n  inclusive values for the focus.  The end is inclusive because it \n  gets a bit dicey if it was 'beyond', since how much beyond would \n  be interesting given the amount of whitespace in the input.\n  Not clear at this point just what the counts in the focus-vec count,\n  possibly things with <anything> == :element, possibly just any\n  [string color <anything>] vector.\n  From this, build of: [[string :style] [string :style] ...], where\n  :style might be a color, like :blue or :none, or it might be a \n  java-text-pane style (which would have a color encoded in it).  This\n  is based on the :style-map in the ctx map. Note that this :style-map\n  doesn't have any relation to the :style-map in the options map."],"~$replace-focus-w-cursor",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",213,"^I",7,"^J",213,"^K",29,"^L",["^M",["^N",["^M",[["~$gcw-vec",["~$focus-start","~$focus-end","~:as","^1="],"~$cursor-vec"]]]]],"^P","Take a [[string :color <anything>] \n           [string :color <anything>] ...] as input.\n  and a focus-vec and, possibly, a non-empty cursor-vec.  If\n  there is a cursor-vec, replace the focus-vec items with a cursor\n  vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n  else just return with no changes"],"^7","~$zprint.finish/replace-focus-w-cursor","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",29,"^S",["^M",[["^1B","~$p__11406","^1F"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",213,"^J",213,"^V",3,"^W",true,"^L",["^M",["^N",["^M",[["^1B",["^1C","^1D","^1E","^1="],"^1F"]]]]],"^P","Take a [[string :color <anything>] \n           [string :color <anything>] ...] as input.\n  and a focus-vec and, possibly, a non-empty cursor-vec.  If\n  there is a cursor-vec, replace the focus-vec items with a cursor\n  vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n  else just return with no changes"],"~$find-line",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",331,"^I",7,"^J",331,"^K",16,"^L",["^M",["^N",["^M",[["~$lines","^14"]]]]],"^P","Given a cvec index, return the line that it is in."],"^7","~$zprint.finish/find-line","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",16,"^S",["^M",[["^1J","^14"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",331,"^J",331,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["^1J","^14"]]]]],"^P","Given a cvec index, return the line that it is in."],"~$index-vec",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",123,"^I",7,"^J",123,"^K",16,"^L",["^M",["^N",["^M",[["^1<"]]]]],"^P","Given a cvec, generate an index vector which can be input to map\n  and will make map work like map-indexed -- unless there are\n  :comment-wrap elements, in which case the :comment-wrap element\n  will have the same element idx as the previous :comment element."],"^7","~$zprint.finish/index-vec","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",16,"^S",["^M",[["^1<"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",123,"^J",123,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^1<"]]]]],"^P","Given a cvec, generate an index vector which can be input to map\n  and will make map work like map-indexed -- unless there are\n  :comment-wrap elements, in which case the :comment-wrap element\n  will have the same element idx as the previous :comment element."],"~$handle-lines",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",375,"^I",7,"^J",375,"^K",19,"^L",["^M",["^N",["^M",[[["~#cmap",[["^ ","~:keys",["~$focus","^1J","~$paths"]],"~:output","^1E","~$options"]],"^1<","^1="]]]]],"^P","Take the current cvec and any focus-vec and the options map,\n  and figure out a set of cvecs to use.  Don't generate lines\n  array unless we need to."],"^7","~$zprint.finish/handle-lines","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",19,"^S",["^M",[["~$p__11459","^1<","^1="]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",375,"^J",375,"^V",3,"^W",true,"^L",["^M",["^N",["^M",[[["^1O",[["^ ","^1P",["^1Q","^1J","^1R"]],"^1S","^1E","^1T"]],"^1<","^1="]]]]],"^P","Take the current cvec and any focus-vec and the options map,\n  and figure out a set of cvecs to use.  Don't generate lines\n  array unless we need to."],"~$cursor-style",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",262,"^I",7,"^J",262,"^K",19,"^L",["^M",["^N",["^M",[[["~$s","~$cursor"],"~$existing-count"],["~$str-cursor"]]]]],"^P","Take a [<string> cursor-number] pair and produce the style-vec\n  that will display it. Allow for existing characters.\n  This is a style-vec that map-style can use, i.e.,\n  [[string <start> <length>] ...]","^1?",["^ ","^R",false,"^V",2,"^S",["^M",[[["~$s","^1X"],"^1Y"],["^1Z"]]],"^L",["^M",[[["~$s","^1X"],"^1Y"],["^1Z"]]],"^U",["^M",[null,null]]]],"^7","~$zprint.finish/cursor-style","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",19,"^1?",["^ ","^R",false,"^V",2,"^S",["^M",[[["~$s","^1X"],"^1Y"],["^1Z"]]],"^L",["^M",[[["~$s","^1X"],"^1Y"],["^1Z"]]],"^U",["^M",[null,null]]],"^S",["^M",[[["~$s","^1X"],"^1Y"],["^1Z"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",262,"^J",262,"^V",2,"^W",true,"^L",["^M",[[["~$s","^1X"],"^1Y"],["^1Z"]]],"^P","Take a [<string> cursor-number] pair and produce the style-vec\n  that will display it. Allow for existing characters.\n  This is a style-vec that map-style can use, i.e.,\n  [[string <start> <length>] ...]"],"~$within-vec?",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",22,"^I",7,"^J",22,"^K",18,"^L",["^M",["^N",["^M",[["~$n","~$low-high-vec"]]]]],"^P","Is n within any of the the closed range of low to high?"],"^7","~$zprint.finish/within-vec?","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",18,"^S",["^M",[["~$n","^21"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",22,"^J",22,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["~$n","^21"]]]]],"^P","Is n within any of the the closed range of low to high?"],"~$cvec-lines",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",298,"^I",7,"^J",298,"^K",17,"^L",["^M",["^N",["^M",[["^1<"]]]]],"^P","Return a vector containing vectors each with the cvec elements \n  for the start and end of each line."],"^7","~$zprint.finish/cvec-lines","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",17,"^S",["^M",[["^1<"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",298,"^J",298,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^1<"]]]]],"^P","Return a vector containing vectors each with the cvec elements \n  for the start and end of each line."],"~$within?",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",17,"^I",7,"^J",17,"^K",14,"^L",["^M",["^N",["^M",[["~$n",["~$low","~$high"]]]]]],"^P","Is n within the closed range of low to high?"],"^7","~$zprint.finish/within?","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",14,"^S",["^M",[["~$n","~$p__11371"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",17,"^J",17,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["~$n",["^26","^27"]]]]]],"^P","Is n within the closed range of low to high?"],"~$surround-focus",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",336,"^I",7,"^J",336,"^K",21,"^L",["^M",["^N",["^M",[["~$lines-to-cvec",["~$focus-begin","^1D"],["~$before","~$after"]]]]]],"^P","Given a cvec and a focus-vec, and the number of line before and after\n  the focus, output a vector of vectors of cvec indicies that cover the \n  desired lines. [[start end] [start end] ...]"],"^7","~$zprint.finish/surround-focus","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",21,"^S",["^M",[["^2;","~$p__11450","~$p__11451"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",336,"^J",336,"^V",3,"^W",true,"^L",["^M",["^N",["^M",[["^2;",["^2<","^1D"],["^2=","^2>"]]]]]],"^P","Given a cvec and a focus-vec, and the number of line before and after\n  the focus, output a vector of vectors of cvec indicies that cover the \n  desired lines. [[start end] [start end] ...]"],"~$fzprint-cursor",["^ ","^7","~$zprint.finish/fzprint-cursor","^G","resources/public/cljs-out/dev/zprint/finish.cljc","^H",260,"^I",1,"^J",260,"^K",30,"~:dynamic",true,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",260,"^I",16,"^J",260,"^K",30,"^2D",true],"^Z","~$cljs.core/IVector"],"~$color-style",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",227,"^I",7,"^J",227,"^K",18,"^L",["^M",["^N",["^M",[[["~$s","~$color"]]]]]],"^P","Turn a [string :color] into an ansi colored string."],"^7","~$zprint.finish/color-style","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",18,"^S",["^M",[["~$p__11413"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",227,"^J",227,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[[["~$s","^2G"]]]]]],"^P","Turn a [string :color] into an ansi colored string."],"~$elide-indent",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",78,"^I",7,"^J",78,"^K",19,"^L",["^M",["^N",["^M",[["~$ssv-element"]]]]],"^P","Take an ssv element which is presumably an indent, and do 1/2\n  of it.  If the argument is nil, do a newline with no indent."],"^7","~$zprint.finish/elide-indent","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",19,"^S",["^M",[["^2K"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",78,"^J",78,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^2K"]]]]],"^P","Take an ssv element which is presumably an indent, and do 1/2\n  of it.  If the argument is nil, do a newline with no indent."],"~$add-length",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",53,"^I",7,"^J",53,"^K",17,"^L",["^M",["^N",["^M",[[["~$s","~$style","~$start"]]]]]],"^P","Given [string :style <start>] turn it into\n  [string :style <start> <length>]"],"^7","~$zprint.finish/add-length","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",17,"^S",["^M",[["~$p__11378"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",53,"^J",53,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[[["~$s","^2N","^2O"]]]]]],"^P","Given [string :style <start>] turn it into\n  [string :style <start> <length>]"],"~$select-lines",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",367,"^I",7,"^J",367,"^K",19,"^L",["^M",["^N",["^M",[["^2;","~$line-vec"]]]]],"^P","line-vec is a vector of individual lines, or two-vecs of\n  line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n  ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n  which maps lines onto cvec ranges."],"^7","~$zprint.finish/select-lines","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",19,"^S",["^M",[["^2;","^2S"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",367,"^J",367,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["^2;","^2S"]]]]],"^P","line-vec is a vector of individual lines, or two-vecs of\n  line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n  ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n  which maps lines onto cvec ranges."],"~$ground-color-to-style",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",27,"^I",7,"^J",27,"^K",28,"^L",["^M",["^N",["^M",[[["^ ","^1P",["~$style-map","^1Q","~$select"]],"~$s","^2G","^16","^14"]]]]],"^P","Ignore any foreground/background designation, and use the\n  focus and the color to figure out a style.  Intimately \n  associated with build-styles.\n  You don't have to have a color, but you do need a ground.\n  If the ground is :c, it is used, otherwise the ground is\n  determined from the focus.  In focus gets :f, otherwise :b.\n  If you don't have a color, the style you get\n  is the same as the key for the ground you get from the\n  focus.  If you don't have a focus, you get the background."],"^7","~$zprint.finish/ground-color-to-style","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",28,"^S",["^M",[["~$p__11375","~$s","^2G","^16","^14"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",27,"^J",27,"^V",5,"^W",true,"^L",["^M",["^N",["^M",[[["^ ","^1P",["^2V","^1Q","^2W"]],"~$s","^2G","^16","^14"]]]]],"^P","Ignore any foreground/background designation, and use the\n  focus and the color to figure out a style.  Intimately \n  associated with build-styles.\n  You don't have to have a color, but you do need a ground.\n  If the ground is :c, it is used, otherwise the ground is\n  determined from the focus.  In focus gets :f, otherwise :b.\n  If you don't have a color, the style you get\n  is the same as the key for the ground you get from the\n  focus.  If you don't have a focus, you get the background."],"~$newline-vec",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",285,"^I",7,"^J",285,"^K",18,"^L",["^M",["^N",["^M",[["~$s"]]]]],"^P","Find out how many newlines are in a string, and where they appear.\n  Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n  for beginning, middle, or end (or all three)."],"^7","~$zprint.finish/newline-vec","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",18,"^S",["^M",[["~$s"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",285,"^J",285,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["~$s"]]]]],"^P","Find out how many newlines are in a string, and where they appear.\n  Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n  for beginning, middle, or end (or all three)."],"~$compress-style",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",181,"^I",7,"^J",181,"^K",21,"^L",["^M",["^N",["^M",[["~$str-style-vec","~$initial-pos"],["^31"]]]]],"^P","Take a [[string :style] [string :style] ...] vector and\n  build a list of: [[string :style <start> <length>] \n                    [string :style <start> <length>]...]\n  from it.  This will compress strings which have the same style.","^1?",["^ ","^R",false,"^V",2,"^S",["^M",[["^31","^32"],["^31"]]],"^L",["^M",[["^31","^32"],["^31"]]],"^U",["^M",[null,null]]]],"^7","~$zprint.finish/compress-style","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",21,"^1?",["^ ","^R",false,"^V",2,"^S",["^M",[["^31","^32"],["^31"]]],"^L",["^M",[["^31","^32"],["^31"]]],"^U",["^M",[null,null]]],"^S",["^M",[["^31","^32"],["^31"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",181,"^J",181,"^V",2,"^W",true,"^L",["^M",[["^31","^32"],["^31"]]],"^P","Take a [[string :style] [string :style] ...] vector and\n  build a list of: [[string :style <start> <length>] \n                    [string :style <start> <length>]...]\n  from it.  This will compress strings which have the same style."],"~$find-range",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",354,"^I",7,"^J",354,"^K",17,"^L",["^M",["^N",["^M",[["^1J","~$line-selector"]]]]],"^P","If given a single integer, return the range from lines.  If given\n  a range of lines, return the beginning of the first line and the end\n  of the last line."],"^7","~$zprint.finish/find-range","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",17,"^S",["^M",[["^1J","^35"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",354,"^J",354,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["^1J","^35"]]]]],"^P","If given a single integer, return the range from lines.  If given\n  a range of lines, return the beginning of the first line and the end\n  of the last line."],"~$replace-nil-seq",["^ ","^E",null,"^F",["^ ","^G","/home/porky/mecca/resources/public/cljs-out/dev/zprint/finish.cljc","^H",89,"^I",7,"^J",89,"^K",22,"^L",["^M",["^N",["^M",[["^13","~$ssv-in","~$elide"]]]]],"^P","Replace all sequences of nil in the sequence with elide"],"^7","~$zprint.finish/replace-nil-seq","^R",false,"^G","resources/public/cljs-out/dev/zprint/finish.cljc","^K",22,"^S",["^M",[["^13","^38","^39"]]],"^T",null,"^U",["^M",[null,null]],"^I",1,"^H",89,"^J",89,"^V",3,"^W",true,"^L",["^M",["^N",["^M",[["^13","^38","^39"]]]]],"^P","Replace all sequences of nil in the sequence with elide"]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:comment-wrap","~:indent","~:element","~:else","~:m","~:lines","~:paths","^1S","~:e","~:surround","~:c","~:last-element","~:elide","~:b","~:style-map","~:focus","~:f","~:cursor-element","~:none","~:reverse","~:select"]],"~:order",["~:f","~:b","~:c","^3K","^3L","^3H","^3I","^3M","^3J","^3@","^3F","^3B","^3?","^3G","^3A","~:e","~:m","^1S","^3C","^3D","^3E"]],"^P",null]